# This file is part of the Rumudge gem
# Copyright (C) 2014 Alex Gladd
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

##
## base abstract controller
##

class Rumudge::Controller
  TAG = 'BaseController'

  attr_reader :next_controller

  def initialize
    # unless session.is_a? Rumudge::Session
    #   raise ArgumentError, 'Argument must be a Rumudge::Session object'
    # end

    # @session = session

    @command = nil
    @params = nil

    @response = nil

    @finished = false
    @next_controller = nil

    # callbacks on start
    run_callbacks __cb_on_start
  end

  # start a round of processing in the controller
  # returns the response generated by the controller
  def action(input = nil)
    Log.d(TAG, "#{self} Beginning action with input=#{input.to_s}")

    # clear response
    @response = nil

    # parse the input
    parse_input input

    # callbacks before command
    run_callbacks __cb_before_cmd

    # do the command
    if command_valid
      process_command
    else
      Log.e(TAG, "#{self} Invalid command received: #{@command}")
    end

    # callbacks after the command
    run_callbacks __cb_after_cmd

    Log.d(TAG, "#{self} Finished action with response='#{@response}'")
    @response
  end

  # process the command and set the response (subclasses may override)
  def process_command
    if self.respond_to? @command, true
      self.send @command
    else
      Log.e(TAG, "#{self} Cannot process command: #{@command}")
    end
  end

  def finished?
    @finished
  end

  private

  def command
    @command
  end

  def params
    @params
  end

  def response=(resp = nil)
    @response = resp
  end

  # signal that this controller should be terminated
  def finish(next_ctrl = nil)
    unless next_ctrl.nil?
      unless next_ctrl.is_a?(Class)
        raise ArgumentError, 'Argument must be a Rumudge::Controller class'
      end
    end

    @finished = true
    @next_controller = next_ctrl

    # callbacks on stop
    run_callbacks __cb_on_stop
  end

  def parse_input(input)
    if input.nil? || input.empty?
      @command = nil
      @params = nil
    else
      parts = input.split(' ')
      @command = parts.shift
      @params = parts
    end
  end

  def run_callbacks(cb_list = [])
    return if cb_list.nil?

    # call each callback if it exists
    cb_list.each do |cb|
      if self.respond_to? cb, true
        self.send cb
      end
    end
  end

  # command filtering

  def command_valid
    false unless __commands_filter.index { |c| c.to_s == @command.to_s } != nil
    true
  end

  # list of commands accepted by this controller
  # subclasses should override
  def __commands_filter
    []
  end

  # set the list of commands this controller should accept
  def self.permitted_commands(*commands)
    class_eval("def __commands_filter; #{commands.to_s}; end") unless commands.nil?
  end

  # callbacks

  def __cb_on_start
    []
  end
  def __cb_before_cmd
    []
  end
  def __cb_after_cmd
    []
  end
  def __cb_on_stop
    []
  end

  # set callbacks for controller startup
  def self.before_start(*callbacks)
    class_eval("def __cb_on_start; #{callbacks.to_s}; end") unless callbacks.nil?
  end

  # set callbacks for before processing command
  def self.before_command(*callbacks)
    class_eval("def __cb_before_cmd; #{callbacks.to_s}; end") unless callbacks.nil?
  end

  # set callbacks for after command processing (before response to client)
  def self.after_command(*callbacks)
    class_eval("def __cb_after_cmd; #{callbacks.to_s}; end") unless callbacks.nil?
  end

  # set callbacks for controller shutdown
  def self.before_stop(*callbacks)
    class_eval("def __cb_on_stop; #{callbacks.to_s}; end") unless callbacks.nil?
  end

end
